
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			#info a, .button {
				color: #f00;
				font-weight: bold;
				text-decoration: underline;
				cursor: pointer
			}
		</style>
	</head>

	<body>

	    
		<div id="info">
		<a href="" target="_blank" rel="noopener"></a>
		</div>


		<script src="./threejs//build/three.js"></script>
		<script src="./threejs//examples/js/controls/OrbitControls.js"></script>
		<script src="./threejs//examples/js/loaders/VRMLLoader.js"></script>
		<script src="./threejs//examples/js/WebGL.js"></script>
		<script src="./threejs//examples/js/libs/stats.min.js"></script>
		<script src="./threejs//examples/js/lines/LineMaterial.js"></script>
		<script src='./threejs//examples/js/lines/LineSegments2.js'></script>
		<script src='./threejs//examples/js/lines/Line2.js'></script>
		<script src='./threejs//examples/js/lines/LineSegmentsGeometry.js'></script>
		<script src='./threejs//examples/js/lines/LineGeometry.js'></script>
		<script src='./threejs//examples/js/lines/WireframeGeometry2.js'></script>
		
	
		<script src="./Renderer/vrml.js"></script>
		<script src="./Renderer/ThreeJs.js"></script>

		<script src="./Renderer/ThreeJs/Animation.js"></script>
		<script src="./Renderer/ThreeJs/VrmlNode.js"></script>
		<script src="./Renderer/ThreeJs/Analyzer.js"></script>
		<script src="./Renderer/ThreeJs/SmoothEdges.js"></script>

		<script src="./Renderer/ThreeJs/VrmlNode/Interpolator.js"></script>
		<script src="./Renderer/ThreeJs/VrmlNode/OrientationInterpolator.js"></script>
		<script src="./Renderer/ThreeJs/VrmlNode/PositionInterpolator.js"></script>
		<script src="./Renderer/ThreeJs/VrmlNode/DirectionalLight.js"></script>
		<script src="./Renderer/ThreeJs/VrmlNode/PointLight.js"></script>
		<script src="./Renderer/ThreeJs/VrmlNode/Text.js"></script>
		<script src="./Renderer/ThreeJs/VrmlNode/Viewpoint.js"></script>
		<script src="./Renderer/ThreeJs/VrmlNode/NavigationInfo.js"></script>
		<script src="./Renderer/ThreeJs/VrmlNode/IndexedFaceSet.js"></script>



		<script>



function parse_query_string(query) {
  var vars = query.split("&");
  var query_string = {};
  for (var i = 0; i < vars.length; i++) {
    var pair = vars[i].split("=");
    var key = decodeURIComponent(pair[0]);
    var value = decodeURIComponent(pair[1]);
    // If first entry with this name
    if (typeof query_string[key] === "undefined") {
      query_string[key] = decodeURIComponent(value);
      // If second entry with this name
    } else if (typeof query_string[key] === "string") {
      var arr = [query_string[key], decodeURIComponent(value)];
      query_string[key] = arr;
      // If third or later entry with this name
    } else {
      query_string[key].push(decodeURIComponent(value));
    }
  }
  return query_string;
}



			function autoFitTo( obj, camera, controls ) {

			  const boundingSphere = new THREE.Box3().setFromObject( obj ).getBoundingSphere();

			  const scale =1.5; // object size / display size
			  const objectAngularSize = ( camera.fov * Math.PI / 180 ) * scale;
			  const distanceToCamera = boundingSphere.radius / Math.tan( objectAngularSize / 2 )
			  const len = Math.sqrt( Math.pow( distanceToCamera, 2 ) + Math.pow( distanceToCamera, 2 ) )

			  camera.position.set(len, len, len);
			  controls.update();

			  camera.lookAt( boundingSphere.center );
			  controls.target.set( boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z );

			  camera.updateProjectionMatrix();

			}



			if ( WEBGL.isWebGLAvailable() === false ) {

				document.body.appendChild( WEBGL.getWebGLErrorMessage() );

			}

			var container, stats;
			var debug = false;
			var camera, controls, scene, renderer;
	
			init();
			animate();

			function init() {
			
		

				var query = window.location.search.substring(1);
				var qs = parse_query_string(query);
		
				console.log(qs);
				
				 if  (qs.path=="")
					qs.path='https://raw.githubusercontent.com/KiCad/kicad-packages3D/master/' +qs.usecase + '.3dshapes/'+ qs.name +'.wrl';
				  else
					 qs.usecase="a";
				
				
			
			
            	var vrmlConverter = new VrmlParser.Renderer.ThreeJs(debug);

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.01, 1e10 );
				camera.position.z = 6;

				controls = new THREE.OrbitControls( camera );

				scene = new THREE.Scene();
				scene.add( camera );

				// light

				var dirLight = new THREE.DirectionalLight( 0xffffff );
				dirLight.position.set( 400,200, 800 ).normalize();

				camera.add( dirLight );
				camera.add( dirLight.target );


				var dirLight1 = new THREE.DirectionalLight( 0xffffff );
				dirLight1.position.set( -400, 200, 800 ).normalize();

				camera.add( dirLight1 );
				camera.add( dirLight1.target );



				
				var fileLoader = new THREE.FileLoader();

                 usecase = qs.usecase
            if (usecase=="")
                {
                    rr="new THREE."+qs.name
                  
                 if (  rr.indexOf("Geometry")   != -1)
                        {
                              
                            geometry=eval(rr);
            //                geometry=new THREE.BoxGeometry( 0.01, 0.01, 0.01 );
            
                            var material = new THREE.MeshBasicMaterial( {color: 0x404f4f} );
            
                        var cube = new THREE.Mesh( geometry, material );
            
                          scene.add(cube)
                          autoFitTo( scene, camera, controls )
            	    	var gridHelper = new THREE.GridHelper(20, 20); // 500 is grid size, 20 is grid step
                          gridHelper.position = new THREE.Vector3(0, 0, 0);
                        gridHelper.rotation = new THREE.Euler(0, 0, 0);
                        scene.add(gridHelper);
                      }

                 scene.background = new THREE.Color( 0x87b5ff );

                }
else

	fileLoader.load(qs.path, function (data) {


		try {
				var tree = vrmlParser.parse(data);
			} catch ( e ) {
				console.log('Exception with message ' + e.message);

				if ( undefined !== e.location ) {
					console.log('Exception at location start: offset: ' + e.location.start.offset + ' line: ' + e.location.start.line + ' column: ' + e.location.start.column);
					console.log('Exception at location end: offset: ' + e.location.end.offset + ' line: ' + e.location.end.line + ' column: ' + e.location.end.column);
				}

				return;
			}
			
					console.log(tree);


t1= qs.path1
if ( t1 !="")
    {
	fileLoader.load(qs.path1, function (data) {
	    	var tree1 = vrmlParser.parse(data);
           	obj1 = new THREE.Scene();
		        vrmlConverter.render(tree1, obj1);
				obj1.scale.set( 2.54,  2.54, 2.54 );
					obj1.position.set( 2.54, 0,0 );
						obj1.rotation.set( - Math.PI / 2,0,0 ) ;
			 scene.add(obj1);
	    	
    });
}
         
             	obj = new THREE.Scene();
		        vrmlConverter.render(tree, obj);
		
				obj.scale.set( 2.54,  2.54, 2.54 );
					obj.rotation.set( - Math.PI / 2,0,0 ) ;
					
			 scene.add(obj);
			 
	        autoFitTo( scene, camera, controls )
		
					
			  
			var gridHelper = new THREE.GridHelper(100, 100); // 500 is grid size, 20 is grid step
			gridHelper.position = new THREE.Vector3(0, 0, 0);
			gridHelper.rotation = new THREE.Euler(0, 0, 0);
			scene.add(gridHelper);


			//var gridHelper2 = new THREE.GridHelper(10, 100);

			//scene.add(gridHelper2);
			//gridHelper2.rotation = new THREE.Euler(Math.PI / 2, 0, 0);
			//var gridHelper3 = gridHelper.clone();
			//gridHelper3.rotation = new THREE.Euler(Math.PI / 2, 0, Math.PI / 2);
			//scene.add(gridHelper3);

			 scene.background = new THREE.Color( 0x87b5ff );
			  camera.updateProjectionMatrix();			

							
				});			
							
				
				// renderer

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container = document.createElement( 'div' );
				document.body.appendChild( container );
				container.appendChild( renderer.domElement );

		//		stats = new Stats();
		//		container.appendChild( stats.dom );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				renderer.render( scene, camera );

	//			stats.update();

			}


		</script>

	</body>
</html>
